# Generated from lib/encoded_id/encoders/my_sqids.rb with RBS::Inline

# Sqids (pronounced "squids") is a library that generates short, unique, non-sequential IDs
# from numbers. It's useful for obfuscating database IDs, creating URL-friendly identifiers,
# and generating human-readable codes.
#
# Key features:
# - Reversible: encoded IDs can be decoded back to the original numbers
# - Customizable: supports custom alphabets, minimum lengths, and blocklists
# - Collision-free: same input always produces the same output
# - Blocklist filtering: automatically regenerates IDs that contain blocked words
#
# The algorithm uses a shuffling mechanism based on the input numbers to select characters
# from a customized alphabet, ensuring that sequential numbers produce non-sequential IDs.
class MySqids
  @blocklist: Array[String] | Set[String]

  @min_length: Integer

  @alphabet: Array[Integer]

  DEFAULT_ALPHABET: ::String

  # Default minimum length of 0 means no padding is applied to generated IDs
  DEFAULT_MIN_LENGTH: ::Integer

  # rubocop:disable Metrics/CollectionLiteralLength, Layout/LineLength
  # Default blocklist containing words that should not appear in generated IDs
  # The blocklist prevents offensive or inappropriate words from appearing in IDs by
  # regenerating IDs that contain these patterns.
  DEFAULT_BLOCKLIST: untyped

  # Maximum integer value that can be encoded
  # Uses Integer::MAX if available (Ruby 2.4+), otherwise calculates the max fixnum value
  # based on the platform's word size
  MAX_INT: untyped

  # Returns the maximum integer value that can be safely encoded
  # @rbs () -> Integer
  def self.max_value: () -> Integer

  # Initializes a new MySqids encoder with custom options
  #
  # @param options [Hash] Configuration options
  # @option options [String, Array<String>] :alphabet Custom alphabet to use for encoding
  #   (default: DEFAULT_ALPHABET). Must be at least 3 characters and contain only single-byte chars.
  # @option options [Integer] :min_length Minimum length for generated IDs (default: 0).
  #   IDs shorter than this will be padded. Must be between 0 and 255.
  # @option options [Array<String>, Set<String>] :blocklist Words to exclude from generated IDs
  #   (default: DEFAULT_BLOCKLIST). Words must be at least 3 characters long.
  #
  # @raise [ArgumentError] If alphabet contains multibyte characters
  # @raise [ArgumentError] If alphabet is shorter than 3 characters
  # @raise [ArgumentError] If alphabet contains duplicate characters
  # @raise [TypeError] If min_length is not between 0 and 255
  #
  # @rbs (?Hash[Symbol, untyped] options) -> void
  def initialize: (?Hash[Symbol, untyped] options) -> void

  # Encodes an array of integers into a single Sqids string
  #
  # The encoding process:
  # 1. Validates all numbers are in valid range (0 to MAX_INT)
  # 2. Generates a prefix character based on the numbers and alphabet
  # 3. Encodes each number using a shuffled alphabet
  # 4. Separates encoded numbers with the first character of the shuffled alphabet
  # 5. Pads the result if it's shorter than min_length
  # 6. Regenerates if the result contains blocklisted words
  #
  # @param numbers [Array<Integer>] Array of non-negative integers to encode
  # @return [String] The encoded Sqids string
  # @raise [ArgumentError] If any number is outside the valid range (0 to MAX_INT)
  #
  # @example
  #   sqids.encode([1, 2, 3])  # => "86Rf07"
  #   sqids.encode([])         # => ""
  #
  # @rbs (Array[Integer] numbers) -> String
  def encode: (Array[Integer] numbers) -> String

  # Decodes a Sqids string back into the original array of integers
  #
  # The decoding process mirrors the encoding:
  # 1. Validates all characters exist in the alphabet
  # 2. Extracts the prefix to determine the alphabet offset
  # 3. Rotates and reverses the alphabet based on the offset
  # 4. Splits the ID by separator characters (first char of shuffled alphabet)
  # 5. Converts each chunk back to its original number
  # 6. Re-shuffles the alphabet between chunks
  #
  # @param id [String] The Sqids string to decode
  # @return [Array<Integer>] Array of integers that were encoded, or empty array if invalid
  #
  # @example
  #   sqids.decode("86Rf07")  # => [1, 2, 3]
  #   sqids.decode("")        # => []
  #   sqids.decode("xyz")     # => [] (if 'xyz' contains invalid chars)
  #
  # @rbs (String id) -> Array[Integer]
  def decode: (String id) -> Array[Integer]

  private

  # Splits an array into two parts at the first occurrence of a separator
  #
  # This is used during decoding to split the encoded ID at separator characters,
  # which mark the boundaries between encoded numbers.
  #
  # @param arr [Array<Integer>] The array to split (character codepoints)
  # @param separator [Integer] The separator character codepoint to split on
  # @return [Array<Array<Integer>>] An array containing the left part (before separator)
  #   and right part (after separator). If separator not found, returns [arr].
  #
  # @example
  #   split_array([1, 2, 3, 4, 5], 3)  # => [[1, 2], [4, 5]]
  #   split_array([1, 2, 3], 9)        # => [[1, 2, 3]]
  #
  # @rbs (Array[Integer] arr, Integer separator) -> Array[Array[Integer]]
  def split_array: (Array[Integer] arr, Integer separator) -> Array[Array[Integer]]

  # Shuffles an array of character codepoints using a consistent, deterministic algorithm
  #
  # This is a key part of the Sqids algorithm. The shuffle is deterministic and reversible,
  # meaning the same input always produces the same output. The algorithm performs a series
  # of swaps based on the current index and character values.
  #
  # The shuffle ensures that:
  # - Sequential numbers don't produce sequential IDs
  # - The same alphabet configuration always produces the same shuffle
  # - The transformation is reversible
  #
  # @param chars [Array<Integer>] Array of character codepoints to shuffle
  # @return [Array<Integer>] The shuffled array (modifies in place and returns)
  #
  # @rbs (Array[Integer] chars) -> Array[Integer]
  def shuffle: (Array[Integer] chars) -> Array[Integer]

  # Internal method to encode an array of numbers into a Sqids string
  #
  # This is the core encoding logic. The process:
  # 1. Calculates an offset based on the numbers and alphabet (ensures uniqueness)
  # 2. Applies an increment if this is a retry (for blocklist filtering)
  # 3. Selects a prefix character from the alphabet at the offset position
  # 4. Rotates and reverses the alphabet based on the offset
  # 5. Encodes each number and separates them with the first shuffled alphabet character
  # 6. Pads to minimum length if needed
  # 7. Checks against blocklist and retries with incremented offset if needed
  #
  # @param numbers [Array<Integer>] Array of integers to encode
  # @param increment [Integer] Retry counter for blocklist collision avoidance (default: 0)
  # @return [String] The encoded Sqids string
  # @raise [ArgumentError] If max retry attempts (alphabet length) is exceeded
  #
  # @rbs (Array[Integer] numbers, ?increment: Integer) -> String
  def encode_numbers: (Array[Integer] numbers, ?increment: Integer) -> String

  # Converts a single number into its encoded representation and appends to the ID
  #
  # This implements a base conversion algorithm where:
  # - The base is (alphabet_length - 1) because the first character is reserved as separator
  # - Characters are added at the start_index position (building the number representation)
  # - The process continues until the number is fully converted
  #
  # The algorithm repeatedly:
  # 1. Takes the remainder (mod alphabet_length - 1) to get the next character index
  # 2. Adds 1 to skip the first character (reserved as separator)
  # 3. Inserts the character into the ID
  # 4. Divides the number by the base to continue with the quotient
  #
  # @param id [Array<Integer>] The ID array being built (modified in place)
  # @param num [Integer] The number to encode
  # @param alphabet [Array<Integer>] The alphabet to use for encoding
  # @return [void] Modifies id in place
  #
  # @rbs (Array[Integer] id, Integer num, Array[Integer] alphabet) -> void
  def to_id: (Array[Integer] id, Integer num, Array[Integer] alphabet) -> void

  # Converts an encoded ID chunk back into its original number
  #
  # This is the inverse of to_id, implementing base conversion from the custom alphabet
  # back to a decimal integer. It processes each character in the ID chunk, treating it
  # as a digit in a positional number system with base (alphabet_length - 1).
  #
  # The algorithm:
  # 1. Finds each character's index in the alphabet
  # 2. Subtracts 1 (because we added 1 during encoding to skip separator)
  # 3. Multiplies accumulator by base and adds the digit value
  #
  # @param id [Array<Integer>] The encoded ID chunk (character codepoints)
  # @param alphabet [Array<Integer>] The alphabet used during encoding
  # @return [Integer] The decoded number
  # @raise [RuntimeError] If a character is not found in the alphabet
  #
  # @rbs (Array[Integer] id, Array[Integer] alphabet) -> Integer
  def to_number: (Array[Integer] id, Array[Integer] alphabet) -> Integer

  # Checks if a generated ID contains any blocklisted words
  #
  # The filtering rules vary by word and ID length:
  # - For very short IDs/words (â‰¤3 chars): requires exact match
  # - For words containing digits: checks if ID starts or ends with the word
  # - For other words: checks if word appears anywhere in the ID
  #
  # This helps prevent offensive or inappropriate words from appearing in generated IDs
  # while minimizing false positives.
  #
  # @param id [String] The generated ID to check
  # @return [Boolean] true if the ID contains a blocklisted word, false otherwise
  #
  # @rbs (String id) -> bool
  def blocked_id?: (String id) -> bool

  # Checks if a string contains any multibyte (non-ASCII) characters
  #
  # Sqids requires single-byte characters only because:
  # - The algorithm uses character codepoints (ord) for shuffling and encoding
  # - Multibyte characters would complicate the mathematical operations
  # - Single-byte ensures consistent behavior across different Ruby versions/platforms
  #
  # @param input_str [String] The string to check
  # @return [Boolean] true if any character requires multiple bytes, false otherwise
  #
  # @rbs (String input_str) -> bool
  def contains_multibyte_chars?: (String input_str) -> bool

  # Rotates and reverses the alphabet based on an offset
  #
  # This transformation is a crucial part of the Sqids algorithm:
  # - Rotation: moves elements from the start to the end by 'offset' positions
  # - Reversal: reverses the entire array order
  #
  # These operations ensure that:
  # - Different input numbers produce different alphabet arrangements
  # - The transformation is deterministic and reproducible during decoding
  # - Sequential numbers don't produce predictable patterns
  #
  # Both encoder and decoder use this to synchronize their alphabet state.
  #
  # @param alphabet [Array<Integer>] The alphabet to transform (character codepoints)
  # @param offset [Integer] Number of positions to rotate
  # @return [Array<Integer>] A new rotated and reversed alphabet
  #
  # @example
  #   rotate_and_reverse_alphabet([1,2,3,4,5], 2)
  #   # => [5, 4, 1, 2, 3] (rotated by 2: [3,4,5,1,2], then reversed)
  #
  # @rbs (Array[Integer] alphabet, Integer offset) -> Array[Integer]
  def rotate_and_reverse_alphabet: (Array[Integer] alphabet, Integer offset) -> Array[Integer]
end
