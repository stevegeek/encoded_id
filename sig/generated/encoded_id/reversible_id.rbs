# Generated from lib/encoded_id/reversible_id.rb with RBS::Inline

# Hashid with a reduced character set Crockford alphabet and split groups
# See: https://www.crockford.com/wrmg/base32.html
# Build with support for https://hashids.org and https://sqids.org
module EncodedId
  type encodeableValue = Array[String | Integer] | String | Integer

  class ReversibleId
    @encoder: untyped

    @hex_represention_encoder: HexRepresentation

    @config: Encoders::BaseConfiguration

    # Factory method to create a Hashid-based reversible ID
    # @rbs (**untyped) -> ReversibleId
    def self.hashid: (**untyped) -> ReversibleId

    # Factory method to create a Sqids-based reversible ID (default)
    # @rbs (**untyped) -> ReversibleId
    def self.sqids: (**untyped) -> ReversibleId

    # Initialize with a configuration object
    # Defaults to Sqids configuration if called with no arguments
    # @rbs (?Encoders::BaseConfiguration? config) -> void
    def initialize: (?Encoders::BaseConfiguration? config) -> void

    # @rbs () -> String?
    def salt: () -> String?

    def min_length: () -> untyped

    def alphabet: () -> untyped

    def split_at: () -> untyped

    def split_with: () -> untyped

    attr_reader hex_represention_encoder: untyped

    def max_length: () -> untyped

    def blocklist: () -> untyped

    attr_reader encoder: untyped

    # Encode the input values into a hash
    # @rbs (encodeableValue values) -> String
    def encode: (encodeableValue values) -> String

    # Encode hex strings into a hash
    # @rbs (encodeableHexValue hexs) -> String
    def encode_hex: (encodeableHexValue hexs) -> String

    # Decode the hash to original array
    # @rbs (String str, ?downcase: bool) -> Array[Integer]
    def decode: (String str, ?downcase: bool) -> Array[Integer]

    # Decode hex strings from a hash
    # @rbs (String str, ?downcase: bool) -> Array[String]
    def decode_hex: (String str, ?downcase: bool) -> Array[String]

    private

    # @rbs (encodeableValue value) -> Array[Integer]
    def prepare_input: (encodeableValue value) -> Array[Integer]

    # @rbs () -> untyped
    def create_encoder: () -> untyped

    # Splits long encoded strings into groups for readability
    # e.g., "ABCDEFGH" with split_at=4, split_with="-" becomes "ABCD-EFGH"
    # @rbs (String hash) -> String
    def humanize_length: (String hash) -> String

    # Reverses humanize_length transformation: removes separators and optionally downcases
    # @rbs (String str, bool downcase) -> String
    def convert_to_hash: (String str, bool downcase) -> String

    # Maps equivalent characters based on alphabet configuration (e.g., 'O' -> '0', 'I' -> '1')
    # @rbs (String str) -> String
    def map_equivalent_characters: (String str) -> String

    # @rbs (String str) -> bool
    def max_length_exceeded?: (String str) -> bool
  end
end
